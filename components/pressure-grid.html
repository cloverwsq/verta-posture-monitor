/**
 * VertA Pressure Grid Visualization
 */

let pressureGridCells = [];
let gridAnimationFrame = null;

function initPressureGrid() {
    const grid = document.getElementById('pressure-grid');
    if (!grid) {
        console.warn('Pressure grid container not found');
        return;
    }

    // æ¸…ç©ºç°æœ‰å†…å®¹
    grid.innerHTML = '';
    pressureGridCells = [];
    
    // åˆ›å»º25ä¸ªä¼ æ„Ÿå™¨å•å…ƒæ ¼ï¼ˆ5x5ç½‘æ ¼ï¼‰
    for (let i = 0; i < 25; i++) {
        const cell = document.createElement('div');
        cell.className = 'pressure-cell';
        cell.dataset.index = i;
        cell.dataset.row = Math.floor(i / 5);
        cell.dataset.col = i % 5;
        
        cell.style.cssText = `
            aspect-ratio: 1;
            border-radius: 6px;
            background: rgba(78, 205, 196, 0.3);
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        `;
        
        // æ·»åŠ ä¼ æ„Ÿå™¨æ ‡è¯†
        const sensorId = document.createElement('span');
        sensorId.textContent = i + 1;
        sensorId.style.cssText = `
            opacity: 0;
            transition: opacity 0.3s ease;
            font-size: 0.6rem;
        `;
        cell.appendChild(sensorId);
        
        // æ·»åŠ äº¤äº’æ•ˆæœ
        addCellInteractions(cell, i);
        
        grid.appendChild(cell);
        pressureGridCells.push({
            element: cell,
            sensorId: sensorId,
            index: i,
            row: Math.floor(i / 5),
            col: i % 5,
            lastValue: 0
        });
    }

    // å¯åŠ¨å‹åŠ›ç½‘æ ¼åŠ¨ç”»
    startPressureAnimation();
    
    console.log('ğŸŒ¡ï¸ Pressure grid initialized with 25 sensors');
}

function addCellInteractions(cell, index) {
    // é¼ æ ‡æ‚¬åœæ•ˆæœ
    cell.addEventListener('mouseenter', () => {
        cell.style.transform = 'scale(1.1)';
        cell.style.zIndex = '10';
        cell.style.boxShadow = '0 4px 15px rgba(78, 205, 196, 0.4)';
        
        // æ˜¾ç¤ºä¼ æ„Ÿå™¨ç¼–å·
        const sensorId = cell.querySelector('span');
        if (sensorId) sensorId.style.opacity = '1';
        
        // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
        showSensorTooltip(cell, index);
    });
    
    cell.addEventListener('mouseleave', () => {
        cell.style.transform = 'scale(1)';
        cell.style.zIndex = '1';
        cell.style.boxShadow = 'none';
        
        // éšè—ä¼ æ„Ÿå™¨ç¼–å·
        const sensorId = cell.querySelector('span');
        if (sensorId) sensorId.style.opacity = '0';
        
        // éšè—æç¤º
        hideTooltip();
    });
    
    // ç‚¹å‡»æ•ˆæœ
    cell.addEventListener('click', () => {
        highlightSensor(index);
    });
}

function showSensorTooltip(cell, index) {
    // åˆ›å»ºæˆ–æ›´æ–°å·¥å…·æç¤º
    let tooltip = document.getElementById('sensorTooltip');
    if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'sensorTooltip';
        tooltip.style.cssText = `
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(78, 205, 196, 0.3);
        `;
        document.body.appendChild(tooltip);
    }
    
    const rect = cell.getBoundingClientRect();
    const value = getCurrentSensorValue(index);
    const row = Math.floor(index / 5) + 1;
    const col = (index % 5) + 1;
    
    tooltip.innerHTML = `
        <strong>Sensor ${index + 1}</strong><br>
        Position: Row ${row}, Col ${col}<br>
        Pressure: ${(value * 100).toFixed(1)}%<br>
        Status: ${getPressureStatus(value)}
    `;
    
    tooltip.style.left = rect.right + 10 + 'px';
    tooltip.style.top = rect.top + 'px';
    tooltip.style.display = 'block';
}

function hideTooltip() {
    const tooltip = document.getElementById('sensorTooltip');
    if (tooltip) {
        tooltip.style.display = 'none';
    }
}

function getCurrentSensorValue(index) {
    if (window.vertaApp && window.vertaApp.sensorData) {
        return window.vertaApp.sensorData[index] || 0;
    }
    return pressureGridCells[index]?.lastValue || 0;
}

function getPressureStatus(value) {
    if (value > 0.8) return 'ğŸ”´ High';
    if (value > 0.5) return 'ğŸŸ¡ Medium';
    if (value > 0.2) return 'ğŸŸ¢ Low';
    return 'âšª None';
}

function highlightSensor(index) {
    // é‡ç½®æ‰€æœ‰ä¼ æ„Ÿå™¨
    pressureGridCells.forEach(cell => {
        cell.element.classList.remove('highlighted');
    });
    
    // é«˜äº®é€‰ä¸­çš„ä¼ æ„Ÿå™¨
    const cell = pressureGridCells[index];
    if (cell) {
        cell.element.classList.add('highlighted');
        cell.element.style.animation = 'pulseHighlight 0.6s ease-in-out';
        
        // æ˜¾ç¤ºä¼ æ„Ÿå™¨è¯¦ç»†ä¿¡æ¯
        if (window.showToast) {
            const value = getCurrentSensorValue(index);
            const row = Math.floor(index / 5) + 1;
            const col = (index % 5) + 1;
            window.showToast(
                `Sensor ${index + 1} (${row},${col}): ${(value * 100).toFixed(1)}% pressure`, 
                'info', 
                3000
            );
        }
        
        setTimeout(() => {
            cell.element.style.animation = '';
        }, 600);
    }
}

function startPressureAnimation() {
    function animate() {
        updatePressureGridVisualization();
        gridAnimationFrame = requestAnimationFrame(animate);
    }
    animate();
}

function stopPressureAnimation() {
    if (gridAnimationFrame) {
        cancelAnimationFrame(gridAnimationFrame);
        gridAnimationFrame = null;
    }
}

function updatePressureGridVisualization() {
    const grid = document.getElementById('pressure-grid');
    if (!grid || pressureGridCells.length === 0) return;

    // è·å–ä¼ æ„Ÿå™¨æ•°æ®
    let sensorData;
    if (window.vertaApp && window.vertaApp.sensorData) {
        sensorData = window.vertaApp.sensorData;
    } else {
        // ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
        sensorData = window.generateMockSensorData ? 
            window.generateMockSensorData('good') : 
            generateDefaultSensorData();
    }
    
    // æ›´æ–°æ¯ä¸ªå•å…ƒæ ¼
    pressureGridCells.forEach((cellInfo, i) => {
        if (i >= sensorData.length) return;
        
        const cell = cellInfo.element;
        const intensity = Math.max(0, Math.min(1, sensorData[i] || 0));
        cellInfo.lastValue = intensity;
        
        // è®¡ç®—é¢œè‰² (ä»è“è‰²åˆ°çº¢è‰²çš„çƒ­å›¾)
        const hue = (1 - intensity) * 240; // 240åº¦æ˜¯è“è‰²ï¼Œ0åº¦æ˜¯çº¢è‰²
        const saturation = 70 + intensity * 30; // é¥±å’Œåº¦
        const lightness = 30 + intensity * 40; // äº®åº¦
        
        cell.style.background = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        
        // æ·»åŠ è„‰åŠ¨æ•ˆæœ
        const pulse = 0.9 + intensity * 0.2;
        if (!cell.style.transform.includes('scale(1.1)')) { // ä¸å¹²æ‰°hoveræ•ˆæœ
            cell.style.transform = `scale(${pulse})`;
        }
        
        // æ›´æ–°è¾¹æ¡†å’Œé˜´å½±
        if (intensity > 0.7) {
            cell.style.border = '2px solid rgba(255, 255, 255, 0.6)';
            cell.style.boxShadow = `0 0 12px hsla(${hue}, ${saturation}%, ${lightness}%, 0.6)`;
        } else if (intensity > 0.4) {
            cell.style.border = '1px solid rgba(255, 255, 255, 0.4)';
            cell.style.boxShadow = `0 0 6px hsla(${hue}, ${saturation}%, ${lightness}%, 0.3)`;
        } else {
            cell.style.border = '1px solid rgba(255, 255, 255, 0.1)';
            cell.style.boxShadow = 'none';
        }
        
        // æ›´æ–°ä¼ æ„Ÿå™¨ç¼–å·é¢œè‰²
        const sensorId = cell.querySelector('span');
        if (sensorId) {
            sensorId.style.color = intensity > 0.5 ? '#ffffff' : 'rgba(255, 255, 255, 0.8)';
        }
    });
}

function generateDefaultSensorData() {
    // ç”Ÿæˆé»˜è®¤çš„ä¼ æ„Ÿå™¨æ•°æ®æ¨¡å¼
    const time = Date.now() / 2000;
    const data = [];
    
    for (let i = 0; i < 25; i++) {
        const row = Math.floor(i / 5);
        const col = i % 5;
        
        // åˆ›å»ºä¸­å¿ƒåé‡çš„å‹åŠ›åˆ†å¸ƒ
        const centerDistance = Math.sqrt(Math.pow(row - 2, 2) + Math.pow(col - 2, 2));
        const centerWeight = Math.exp(-centerDistance * 0.5);
        
        // æ·»åŠ æ—¶é—´å˜åŒ–
        const timeVariation = Math.sin(time + i * 0.2) * 0.3;
        
        let value = centerWeight * 0.7 + timeVariation + 0.2;
        value = Math.max(0, Math.min(1, value));
        
        data.push(value);
    }
    
    return data;
}

// å‹åŠ›ç½‘æ ¼åˆ†æåŠŸèƒ½
function analyzePressureDistribution() {
    if (!window.vertaApp || !window.vertaApp.sensorData) {
        return null;
    }
    
    const data = window.vertaApp.sensorData;
    let totalPressure = 0;
    let maxPressure = 0;
    let minPressure = Infinity;
    let centerOfPressure = { x: 0, y: 0 };
    
    // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    for (let i = 0; i < 25; i++) {
        const pressure = data[i] || 0;
        const row = Math.floor(i / 5);
        const col = i % 5;
        
        totalPressure += pressure;
        maxPressure = Math.max(maxPressure, pressure);
        minPressure = Math.min(minPressure, pressure);
        
        centerOfPressure.x += pressure * col;
        centerOfPressure.y += pressure * row;
    }
    
    if (totalPressure > 0) {
        centerOfPressure.x /= totalPressure;
        centerOfPressure.y /= totalPressure;
    }
    
    // è®¡ç®—å¯¹ç§°æ€§
    let leftSidePressure = 0;
    let rightSidePressure = 0;
    
    for (let i = 0; i < 25; i++) {
        const col = i % 5;
        const pressure = data[i] || 0;
        
        if (col < 2) leftSidePressure += pressure;
        if (col > 2) rightSidePressure += pressure;
    }
    
    const asymmetryRatio = Math.abs(leftSidePressure - rightSidePressure) / 
                          (leftSidePressure + rightSidePressure);
    
    return {
        totalPressure: totalPressure.toFixed(2),
        averagePressure: (totalPressure / 25).toFixed(3),
        maxPressure: maxPressure.toFixed(3),
        minPressure: minPressure === Infinity ? 0 : minPressure.toFixed(3),
        centerOfPressure: {
            x: centerOfPressure.x.toFixed(2),
            y: centerOfPressure.y.toFixed(2)
        },
        asymmetryRatio: asymmetryRatio.toFixed(3),
        symmetryStatus: asymmetryRatio < 0.1 ? 'Good' : asymmetryRatio < 0.2 ? 'Fair' : 'Poor'
    };
}

// é‡ç½®ç½‘æ ¼æ˜¾ç¤º
function resetPressureGrid() {
    pressureGridCells.forEach(cellInfo => {
        const cell = cellInfo.element;
        cell.style.background = 'rgba(78, 205, 196, 0.3)';
        cell.style.border = '1px solid rgba(255, 255, 255, 0.1)';
        cell.style.boxShadow = 'none';
        cell.style.transform = 'scale(1)';
        cell.classList.remove('highlighted');
        cellInfo.lastValue = 0;
    });
}

// è®¾ç½®ç½‘æ ¼ä¸»é¢˜
function setPressureGridTheme(theme = 'default') {
    const themes = {
        default: { base: 'rgba(78, 205, 196, 0.3)', accent: '#4ecdc4' },
        fire: { base: 'rgba(255, 107, 107, 0.3)', accent: '#ff6b6b' },
        ice: { base: 'rgba(107, 178, 255, 0.3)', accent: '#6bb2ff' },
        forest: { base: 'rgba(107, 255, 107, 0.3)', accent: '#6bff6b' }
    };
    
    const selectedTheme = themes[theme] || themes.default;
    
    pressureGridCells.forEach(cellInfo => {
        cellInfo.element.style.background = selectedTheme.base;
    });
}

// æ·»åŠ å¿…è¦çš„CSSåŠ¨ç”»
function addPressureGridStyles() {
    if (document.getElementById('pressureGridStyles')) return;
    
    const style = document.createElement('style');
    style.id = 'pressureGridStyles';
    style.textContent = `
        @keyframes pulseHighlight {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); box-shadow: 0 0 20px rgba(78, 205, 196, 0.8); }
            100% { transform: scale(1); }
        }
        
        .pressure-cell.highlighted {
            border: 2px solid #4ecdc4 !important;
            z-index: 15 !important;
        }
        
        .pressure-cell {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .pressure-cell:hover {
            transition: all 0.2s ease !important;
        }
    `;
    document.head.appendChild(style);
}

// åˆå§‹åŒ–æ—¶æ·»åŠ æ ·å¼
addPressureGridStyles();

// å¯¼å‡ºå‡½æ•°
window.initPressureGrid = initPressureGrid;
window.updatePressureGridVisualization = updatePressureGridVisualization;
window.analyzePressureDistribution = analyzePressureDistribution;
window.resetPressureGrid = resetPressureGrid;
window.setPressureGridTheme = setPressureGridTheme;
window.highlightSensor = highlightSensor;
window.startPressureAnimation = startPressureAnimation;
window.stopPressureAnimation = stopPressureAnimation;

console.log('ğŸŒ¡ï¸ Pressure grid module loaded');